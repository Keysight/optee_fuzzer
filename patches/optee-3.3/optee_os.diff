diff --git a/core/arch/arm/pta/afl.c b/core/arch/arm/pta/afl.c
new file mode 100644
index 0000000..970a676
--- /dev/null
+++ b/core/arch/arm/pta/afl.c
@@ -0,0 +1,114 @@
+#include <compiler.h>
+#include <stdio.h>
+#include <trace.h>
+#include <kernel/pseudo_ta.h>
+#include <mm/tee_pager.h>
+#include <mm/tee_mm.h>
+#include <string.h>
+#include <string_ext.h>
+#include <malloc.h>
+#include <kernel/afl.h>
+
+#define TA_NAME         "afl.ta"
+
+#define AFL_UUID { 0xd96a5b41, 0xe2c8, 0xb1af, { 0x87, 0x94, 0x10, 0x03, 0xa5, 0xd5, 0xc7, 0x1b } }
+
+#define AFL_PTA_CMD_ENABLE_SVC_TRACE            0
+#define AFL_PTA_CMD_DISABLE_SVC_TRACE           1
+#define AFL_PTA_CMD_COPY_FULL_MAP               2
+#define AFL_PTA_CMD_RESET_FULL_MAP              3
+
+
+static TEE_Result enable_svc_trace(uint32_t type, TEE_Param p[TEE_NUM_PARAMS])
+{
+    if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE) != type) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    DMSG("Enable SVC tracing for session %x", p[0].value.a);
+
+    return afl_svc_trace_start(p[0].value.a);
+}
+
+static TEE_Result disable_svc_trace(uint32_t type, TEE_Param p[TEE_NUM_PARAMS])
+{
+    if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+                        TEE_PARAM_TYPE_MEMREF_OUTPUT,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE) != type) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    DMSG("Disable SVC tracing for session %x", p[0].value.a);
+
+    return afl_svc_trace_stop(p[0].value.a, p[1].memref.buffer, &p[1].memref.size);
+}
+
+#ifdef AFL_FULL_MAP
+static TEE_Result copy_full_map(uint32_t type, TEE_Param p[TEE_NUM_PARAMS])
+{
+    if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_OUTPUT,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE) != type) {
+        EMSG("expect 1 output values as argument");
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (p[0].memref.size < FULL_MAP_SIZE) {
+        EMSG("Output buffer too small");
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    afl_copy_full_map(p[0].memref.buffer, &p[0].memref.size);
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result reset_full_map(uint32_t type, TEE_Param p[TEE_NUM_PARAMS])
+{
+    if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE) != type) {
+        EMSG("expect no arguments");
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    afl_reset_full_map();
+
+    return TEE_SUCCESS;
+}
+#endif
+
+/*
+ * Trusted Application Entry Points
+ */
+
+static TEE_Result invoke_command(void *psess __unused,
+                                 uint32_t cmd, uint32_t ptypes,
+                                 TEE_Param params[TEE_NUM_PARAMS])
+{
+    switch (cmd) {
+        case AFL_PTA_CMD_ENABLE_SVC_TRACE:
+            return enable_svc_trace(ptypes, params);
+        case AFL_PTA_CMD_DISABLE_SVC_TRACE:
+            return disable_svc_trace(ptypes, params);
+#ifdef AFL_FULL_MAP
+        case AFL_PTA_CMD_COPY_FULL_MAP:
+            return copy_full_map(ptypes, params);
+        case AFL_PTA_CMD_RESET_FULL_MAP:
+            return reset_full_map(ptypes, params);
+#endif
+        default:
+            break;
+    }
+    return TEE_ERROR_BAD_PARAMETERS;
+}
+
+pseudo_ta_register(.uuid = AFL_UUID, .name = TA_NAME,
+                   .flags = PTA_DEFAULT_FLAGS,
+                   .invoke_command_entry_point = invoke_command);
diff --git a/core/include/kernel/afl.h b/core/include/kernel/afl.h
new file mode 100644
index 0000000..dcfb81c
--- /dev/null
+++ b/core/include/kernel/afl.h
@@ -0,0 +1,80 @@
+#ifndef __KERNEL_AFL_H
+#define __KERNEL_AFL_H
+
+#include <assert.h>
+#include <kernel/tee_ta_manager.h>
+
+#define AFL_FULL_MAP
+//#define AFL_DEBUG
+
+#define MAP_SIZE (1 << 16)
+#define FULL_MAP_SIZE (1 << 16)
+
+typedef struct afl_ctx {
+    bool enabled;
+    char bitmap[MAP_SIZE];
+    uint64_t prev_loc;
+
+    void* input;
+    size_t input_len;
+};
+
+typedef struct afl_svc_trace_ctx {
+    bool trace_enabled;
+
+    // cmd buffer
+    void* cmd_buf; /* malloc */
+    void* cmd_buf_last_p;
+    void* cmd_buf_last_append_p;
+
+    // data buffer
+    void* data_buf;  /* malloc */
+    void* data_buf_append_p;
+
+    // buffer ids
+    uint32_t num_bufs;
+    void** buf_ptrs;  /* malloc */
+    uint32_t* buf_sizes;  /* malloc */
+
+    // handles
+    uint32_t num_handles;
+    uint32_t* handles;  /* malloc */
+    uint32_t* handle_buf_ids;  /* malloc */
+};
+
+/* called from thread.c */
+void __afl_thread_suspend(void);
+void __afl_thread_resume(void);
+
+struct thread_svc_regs;
+
+void __afl_svc_trace_log_call(uint64_t scn, struct thread_svc_regs *regs, uint64_t* args);
+void __afl_svc_trace_log_call_post(uint64_t scn, const struct thread_svc_regs *regs, const uint64_t* args);
+
+/* called by afl-tee TA */
+TEE_Result syscall_afl_cov_bitmap_init(void* input, size_t input_len);
+TEE_Result syscall_afl_cov_bitmap_shutdown(void* dst);
+
+/* called by afl-tee PTA */
+TEE_Result afl_svc_trace_start(uint32_t session_id);
+TEE_Result afl_svc_trace_stop(uint32_t session_id, void* dst, uint32_t* dst_len);
+
+#ifdef AFL_FULL_MAP
+TEE_Result afl_copy_full_map(void* buf, size_t* buf_len);
+TEE_Result afl_reset_full_map();
+#endif
+
+static inline struct afl_ctx* __afl_ctx_ptr(void) {
+    register uintptr_t ptr;
+
+    /* Note: tpidrro_el0 is readable by EL0, however this will only leak a kernel VA */
+    __asm volatile ("mrs %0, tpidrro_el0" : "=r" (ptr) );
+
+    return (struct afl_ctx*)ptr;
+}
+
+static inline void __afl_set_ctx_ptr(struct afl_ctx* ptr) {
+    asm volatile("msr tpidrro_el0, %0" :: "r" (ptr) : "memory");
+}
+
+#endif
\ No newline at end of file
diff --git a/core/kernel/afl.c b/core/kernel/afl.c
new file mode 100644
index 0000000..bf4dd07
--- /dev/null
+++ b/core/kernel/afl.c
@@ -0,0 +1,173 @@
+#include <assert.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <trace.h>
+#include <initcall.h>
+
+#include <platform_config.h>
+
+#include <kernel/afl.h>
+#include <kernel/panic.h>
+#include <kernel/linker.h>
+
+#ifdef CFG_CORE_UNMAP_CORE_AT_EL0
+#error AFL support is incompatible with CFG_CORE_UNMAP_CORE_AT_EL0
+#endif
+
+extern uint8_t __afl_text_start[];
+extern uint8_t __afl_text_end[];
+
+static uintptr_t _text_start = &__afl_text_start;
+static uintptr_t _text_end = &__afl_text_end;
+
+#define afl_cov_is_enabled(task_id) ((__afl_cov_enabled & ((uint64_t)1 << task_id)) != 0)
+#define afl_cov_enable(task_id) do { __afl_cov_enabled |= (uint64_t)1 << task_id; } while(0);
+#define afl_cov_disable(task_id) do { __afl_cov_enabled &= ~((uint64_t)1 << task_id); } while(0);
+
+#ifdef AFL_FULL_MAP
+static uint8_t __afl_cov_full_map[FULL_MAP_SIZE];
+#endif
+
+#define unlikely(x)     __builtin_expect((x),0)
+
+void __sanitizer_cov_trace_pc(void);
+
+__attribute__( ( always_inline ) ) static inline uint32_t __get_LR(void) {
+    register uintptr_t result;
+
+    __asm volatile ("mov %0, x30\n" : "=r" (result) );
+
+    return(result);
+}
+
+void __afl_reset_thread_ctx(void) {
+    // Set thread info registers to default values
+    __afl_set_ctx_ptr(0);
+}
+
+void __afl_thread_suspend(void) {
+    __afl_reset_thread_ctx();
+}
+
+void __afl_thread_resume(void) {
+    struct tee_ta_session *sess;
+
+    //EMSG("Resume: tee_ta_get_current_session(&sess) == TEE_SUCCESS: %x", tee_ta_get_current_session(&sess) == TEE_SUCCESS);    
+
+    if (tee_ta_get_current_session(&sess) == TEE_SUCCESS && sess->afl_ctx && sess->afl_ctx->enabled) {
+        __afl_set_ctx_ptr(sess->afl_ctx);
+    }
+}
+
+void __sanitizer_cov_trace_pc(void) {
+    uintptr_t addr = (uintptr_t) __get_LR();
+
+    struct afl_ctx* ctx = __afl_ctx_ptr();
+
+    if (ctx != NULL) {
+#ifdef AFL_FULL_MAP
+        uintptr_t map_addr = (addr - _text_start) >> 1;
+        size_t map_idx = map_addr / 8;
+        size_t map_bit = map_addr % 8;
+
+        assert(map_idx < sizeof(__afl_cov_full_map));
+
+        __afl_cov_full_map[map_idx] |= 1u << map_bit;
+#endif
+
+#ifdef AFL_DEBUG
+        struct tee_ta_session *sess;
+
+        assert(tee_ta_get_current_session(&sess) == TEE_SUCCESS);
+
+        if (sess->afl_ctx != ctx) {
+            EMSG("ctx: %p != %p", sess->afl_ctx, ctx);
+            assert(sess->afl_ctx == ctx);
+        }
+#endif
+
+        // Right shift 1 as instructions are 2-byte (thumb) or 4-byte aligned(arm or aarch64)
+        addr = (addr >> 1);
+
+        //if ((ctx->prev_loc & (~(MAP_SIZE - 1))) != 0) {
+        //    EMSG("Incorrect prev_loc: %x mask: %x val: %x", ctx->prev_loc, (~(MAP_SIZE - 1)), ctx->prev_loc & (~(MAP_SIZE - 1)));
+        //    assert((ctx->prev_loc & (~(MAP_SIZE - 1))) == 0);
+        //}
+
+        ctx->bitmap[(addr ^ ctx->prev_loc) & (MAP_SIZE - 1)]++;
+        //ctx->prev_loc = (addr >> 1) & (MAP_SIZE - 1);
+        ctx->prev_loc = (addr >> 1); 
+    }
+}
+
+TEE_Result syscall_afl_cov_bitmap_init(void* input, size_t input_len) {
+    struct tee_ta_session *sess;
+
+    assert(tee_ta_get_current_session(&sess) == TEE_SUCCESS);
+
+    assert(sess->afl_ctx == NULL);
+    assert(__afl_ctx_ptr() == NULL);
+
+    sess->afl_ctx = malloc(sizeof(struct afl_ctx));
+
+    if (unlikely(sess->afl_ctx == NULL)) {
+        EMSG("Out of memory");
+        panic();
+    }
+
+    memset(sess->afl_ctx, 0, sizeof(struct afl_ctx));
+
+    sess->afl_ctx->input = input;
+    sess->afl_ctx->input_len = input_len;
+
+    return TEE_SUCCESS;
+}
+
+TEE_Result syscall_afl_cov_bitmap_shutdown(void* dst) {
+    struct tee_ta_session *sess;
+
+    assert(tee_ta_get_current_session(&sess) == TEE_SUCCESS);
+
+    assert(sess->afl_ctx != NULL);
+    assert(__afl_ctx_ptr() == NULL);
+
+    if (dst) {
+        memcpy(dst, sess->afl_ctx->bitmap, MAP_SIZE);
+    }
+
+    free(sess->afl_ctx);
+    sess->afl_ctx = NULL;
+
+    return TEE_SUCCESS;
+}
+
+#ifdef AFL_FULL_MAP
+TEE_Result afl_copy_full_map(void* buf, size_t* buf_len) {
+    memcpy(buf, __afl_cov_full_map, FULL_MAP_SIZE);
+
+    *buf_len = FULL_MAP_SIZE;
+
+    return TEE_SUCCESS;
+}
+
+TEE_Result afl_reset_full_map() {
+    memset(__afl_cov_full_map, 0, FULL_MAP_SIZE);
+
+    return TEE_SUCCESS;
+}
+
+TEE_Result afl_init(void)
+{
+    EMSG("AFL cov Start: %x End: %x Map: %x (need: %x)", _text_start, _text_end, sizeof(__afl_cov_full_map), (_text_end - _text_start) / 8ull / 2ull);
+
+    assert((_text_end - _text_start) / 8ull / 2ull < sizeof(__afl_cov_full_map));
+
+    __afl_reset_thread_ctx();
+
+    return TEE_SUCCESS;
+}
+
+driver_init(afl_init);
+#endif
\ No newline at end of file
diff --git a/core/kernel/afl_svc_trace.c b/core/kernel/afl_svc_trace.c
new file mode 100644
index 0000000..c5bfa94
--- /dev/null
+++ b/core/kernel/afl_svc_trace.c
@@ -0,0 +1,856 @@
+#include <assert.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <trace.h>
+#include <util.h>
+
+#include <kernel/panic.h>
+#include <kernel/thread.h>
+#include <kernel/tee_ta_manager.h>
+
+#include <mm/tee_mmu.h>
+
+#include <tee/tee_svc.h>
+
+#include <initcall.h>
+#include <platform_config.h>
+#include <tee_syscall_numbers.h>
+
+#include <kernel/afl.h>
+
+// evil hack
+#define abort panic
+
+#include "../../../afl-tee/shared/info.c"
+#include "../../../afl-tee/shared/validate.c"
+
+#include "../../../afl-tee/shared/include/afl-tee-trace.h"
+
+static bool has_buffer(struct afl_svc_trace_ctx* ctx, void* ptr, size_t size) {
+    if (ctx->buf_ptrs && ctx->buf_sizes) {
+        for (uint32_t i = 0; i < ctx->num_bufs; i++) {
+            if (ctx->buf_ptrs[i] == ptr && size <= ctx->buf_sizes[i]) {
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+static uint32_t lookup_buffer_id(struct afl_svc_trace_ctx* ctx, void* ptr, size_t size) {
+    if (ctx->buf_ptrs && ctx->buf_sizes) {
+        for (uint32_t i = 0; i < ctx->num_bufs; i++) {
+            if (ctx->buf_ptrs[i] == ptr && size <= ctx->buf_sizes[i]) {
+                return i;
+            }
+        }
+    }
+
+    assert(0);
+}
+
+static uint32_t assign_buffer_id(struct afl_svc_trace_ctx* ctx, void* ptr, size_t size) {
+    assert(ctx->num_bufs + 1 < MAX_BUF_COUNT);
+
+    ctx->buf_ptrs = (void**)realloc(ctx->buf_ptrs, (ctx->num_bufs + 1) * sizeof(void*));
+    ctx->buf_sizes = (uint32_t*)realloc(ctx->buf_sizes, (ctx->num_bufs + 1) * sizeof(&ctx->buf_sizes[0]));
+
+    assert(ctx->buf_ptrs != NULL);
+    assert(ctx->buf_sizes != NULL);
+
+    ctx->buf_ptrs[ctx->num_bufs] = ptr;
+    ctx->buf_sizes[ctx->num_bufs] = size;
+
+    return ctx->num_bufs++;
+}
+
+static inline size_t get_buf_size(uint32_t scn, uint64_t* args, uint64_t arg_info) {
+    uint8_t len_arg_nr = GET_ARG_BUF_LEN_ARG(arg_info);
+    uint8_t arg_buf_size = GET_ARG_BUF_SIZE(arg_info);
+
+    //EMSG("get_buf_size(%x, %p, %x)", scn, args, arg_info);
+    //EMSG(" len_arg_nr = %x", len_arg_nr);
+    //EMSG(" arg_buf_size = %x", arg_buf_size);
+    
+    if (len_arg_nr < syscall_num_args(scn)) {
+        uint32_t len_arg_info = syscall_arg_info(scn, len_arg_nr);
+
+        //EMSG(" len_arg_info = %x", len_arg_info);
+
+        switch (len_arg_info & 0xFF) {
+            case ARG_VALUE:
+                if (arg_buf_size > 0) {
+                    return args[len_arg_nr] * arg_buf_size;
+                }
+                else {
+                    return args[len_arg_nr];
+                }
+
+            case ARG_VALUE_INOUT_PTR: {
+                uint32_t len = 0;
+
+                if (tee_svc_copy_from_user(&len, args[len_arg_nr], sizeof(len)) == TEE_SUCCESS) {
+                    if (arg_buf_size > 0) {
+                        return len * arg_buf_size;
+                    }
+                    else {
+                        return len;
+                    }
+                }
+                break;
+            }
+
+            default:
+                EMSG("Unexpected arg type: %x", len_arg_info);
+                assert(0);
+        }
+    }
+    else if (arg_buf_size > 0) {
+        return arg_buf_size;
+    }
+
+    return SIZE_MAX;
+}
+
+static inline bool has_handle(struct afl_svc_trace_ctx* ctx, uint32_t handle) {
+    for (uint32_t i = 0; i < ctx->num_handles; i++) {
+        if (ctx->handles[i] == handle) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+static inline uint32_t lookup_handle_buffer_id(struct afl_svc_trace_ctx* ctx, uint32_t handle) {
+    for (uint32_t i = 0; i < ctx->num_handles; i++) {
+        if (ctx->handles[i] == handle) {
+            return ctx->handle_buf_ids[i];
+        }
+    }
+
+    assert(0);
+}
+
+static inline void track_created_handles(struct afl_svc_trace_ctx* ctx, uint32_t scn, uint64_t* args) {
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_HANDLE_OUT_PTR:
+                {
+                    uint32_t handle;
+
+                    assert(has_buffer(ctx, (void*)args[i], sizeof(handle))); // we should have one assigned in append_cmd()
+                    assert(tee_svc_copy_from_user(&handle, (void*)args[i], sizeof(handle)) == TEE_SUCCESS);
+
+                    if (has_handle(ctx, handle)) {
+                        assert(lookup_handle_buffer_id(ctx, handle) == lookup_buffer_id(ctx, (void*)args[i], sizeof(handle)));
+                    }
+                    else { // register as a new handle
+                        ctx->handles = realloc(ctx->handles, (ctx->num_handles + 1) * sizeof(handle));
+                        ctx->handle_buf_ids = realloc(ctx->handle_buf_ids, (ctx->num_handles + 1) * sizeof(handle));
+
+                        assert(ctx->handles != NULL);
+                        assert(ctx->handle_buf_ids != NULL);
+
+                        ctx->handles[ctx->num_handles] = handle;
+                        ctx->handle_buf_ids[ctx->num_handles] = lookup_buffer_id(ctx, (void*)args[i], sizeof(handle));
+
+                        ctx->num_handles++;
+                    }
+                }
+                break;
+        }
+    }
+}
+
+static inline void print_invoke_syscall_info(uint32_t scn, uint64_t* args) {
+    static char buf[256] = {0};
+
+    size_t off = 0;
+
+    off += snprintf(&buf[off], sizeof(buf) - off, "%s[%i](", syscall_name(scn), scn);
+
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        if (i >= 1) {
+            off += snprintf(&buf[off], sizeof(buf) - off, ", ");
+        }
+
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_VALUE:
+            case ARG_HANDLE:
+
+            case ARG_VALUE_OUT_PTR:
+            case ARG_HANDLE_OUT_PTR:
+                off += snprintf(&buf[off], sizeof(buf) - off, "%x", args[i]);
+                break;
+
+            case ARG_VALUE_INOUT_PTR:
+                {
+                    uint32_t val;
+
+                    if (tee_svc_copy_from_user(&val, (void*)args[i], sizeof(val)) == TEE_SUCCESS) {
+                        off += snprintf(&buf[off], sizeof(buf) - off, "%x=%x", args[i], val);    
+                    }
+                    else {
+                        off += snprintf(&buf[off], sizeof(buf) - off, "%x=<invalid addr>", args[i]);    
+                    }
+                }
+                break;
+
+            case ARG_BUF_IN_ADDR:
+            case ARG_BUF_OUT_ADDR:
+            case ARG_BUF_INOUT_ADDR:
+                off += snprintf(&buf[off], sizeof(buf) - off, "*%x:%x", args[i], get_buf_size(scn, args, arg_info));
+                break;
+
+            default:
+                assert(0);
+        }
+    }
+
+    trace_ext_puts(buf);
+
+    // Dump attributes
+    off = 0;
+    off += snprintf(&buf[off], sizeof(buf) - off, ")\n");
+
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_BUF_IN_ADDR:
+            case ARG_BUF_INOUT_ADDR:
+                if (GET_ARG_BUF_TYPE(arg_info) > 0) {
+                    switch (GET_ARG_BUF_TYPE(arg_info)) {
+                        case ARG_TYPE_ATTR: 
+                            {
+                                uint32_t num_args = get_buf_size(scn, args, arg_info) / sizeof(struct utee_attribute);
+
+                                assert(get_buf_size(scn, args, arg_info) % sizeof(struct utee_attribute) == 0);
+
+                                struct utee_attribute attr;
+
+                                for (uint32_t attrn = 0; attrn < num_args; attrn++) {
+                                    assert(tee_svc_copy_from_user(&attr, &((struct utee_attribute*)args[i])[attrn], sizeof(attr)) == TEE_SUCCESS);
+
+                                    off += snprintf(&buf[off], sizeof(buf) - off, " attr %x { id: %x, a: %x, b: %x }\n", attrn, attr.attribute_id, attr.a, attr.b);
+                                }
+                            }
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+        }
+    }
+
+    trace_ext_puts(buf);
+}
+
+static inline void print_post_invoke_syscall_info(uint32_t scn, uint64_t* args, uint32_t ret_val) {
+    static char buf[256] = {0};
+    size_t off = 0;
+
+    bool had_first = false;
+
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        if (had_first) {
+            off += snprintf(&buf[off], sizeof(buf) - off, ", ");
+        }
+
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_HANDLE_OUT_PTR:
+                if (had_first) {
+                    off += snprintf(&buf[off], sizeof(buf) - off, ", ");
+                }
+                else {
+                    off += snprintf(&buf[off], sizeof(buf) - off, " [");
+                    had_first = true;
+                }
+
+                off += snprintf(&buf[off], sizeof(buf) - off, "*%p = %x", args[i], *((uint32_t*)args[i]));
+                break;
+        }
+    }
+
+    if (had_first) {
+        off += snprintf(&buf[off], sizeof(buf) - off, "]\n");
+    }
+
+    if (off > 0)
+        trace_ext_puts(buf);
+}
+
+static void validate_args(uint64_t scn, uint64_t* args) {
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_VALUE:
+            case ARG_HANDLE:
+
+            case ARG_VALUE_OUT_PTR:
+            case ARG_VALUE_INOUT_PTR:
+            case ARG_HANDLE_OUT_PTR: // Upper bits are not used
+                assert((arg_info >> 8) == 0);
+                break;
+
+            case ARG_BUF_IN_ADDR:
+            case ARG_BUF_OUT_ADDR:
+            case ARG_BUF_INOUT_ADDR:
+                //assert(get_buf_size(scn, args, arg_info) != SIZE_MAX);
+                //assert(get_buf_size(scn, args, arg_info) < 1 << 20);
+                break;
+
+            default:
+                EMSG("validate_args(): Unexpected arg type: %x", arg_info);
+                assert(0);
+        }
+    }
+}
+
+static inline bool is_valid_address(void* addr, size_t len) {
+    struct tee_ta_session *s;
+
+    if (tee_ta_get_current_session(&s) != TEE_SUCCESS)
+        assert(0);
+
+    return tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx),
+                                       TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,
+                                       (uaddr_t)addr, len) == TEE_SUCCESS;
+}
+
+static uint32_t determine_arg_type(struct afl_svc_trace_ctx* ctx, uint64_t scn, uint64_t* args) {
+    uint32_t cmd_arg_type = 0;
+
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_VALUE:
+                SET_ARG_TYPE(cmd_arg_type, i, ARG_VALUE_32);
+                break;
+
+            case ARG_HANDLE:
+                // There are a bunch of test cases that use bad handles
+                // Also, in some cases the handle is optional
+                if (has_handle(ctx, args[i])) { 
+                    SET_ARG_TYPE(cmd_arg_type, i, ARG_BUFFER_DEREF32);
+                }
+                else {
+                    SET_ARG_TYPE(cmd_arg_type, i, ARG_VALUE_32);
+                }
+                break;
+
+            case ARG_VALUE_OUT_PTR:
+            case ARG_HANDLE_OUT_PTR:
+            case ARG_BUF_OUT_ADDR:
+                {
+                    void* buf_ptr = (void*)args[i];
+                    size_t buf_size = (((arg_info & 0xFF) == ARG_VALUE_OUT_PTR || (arg_info & 0xFF) == ARG_HANDLE_OUT_PTR) ? sizeof(uint64_t) : get_buf_size(scn, args, arg_info));
+
+                    if (is_valid_address(buf_ptr, buf_size) && buf_size) {
+                        if (has_buffer(ctx, (void*)args[i], buf_size)) {
+                            SET_ARG_TYPE(cmd_arg_type, i, ARG_BUFFER_REF);
+                        }
+                        else {
+                            SET_ARG_TYPE(cmd_arg_type, i, ARG_BUFFER_ALLOC);
+                        }
+                    }
+                    else {
+                        EMSG("Ignore invalid address: %p:%x", buf_ptr, buf_size);
+
+                        SET_ARG_TYPE(cmd_arg_type, i, ARG_VALUE_32);
+                    }
+                }
+                break;
+
+            case ARG_VALUE_INOUT_PTR:
+            case ARG_BUF_IN_ADDR:
+            case ARG_BUF_INOUT_ADDR:
+                {
+                    void* buf_ptr = (void*)args[i];
+                    size_t buf_size = (((arg_info & 0xFF) == ARG_VALUE_INOUT_PTR) ? sizeof(uint64_t) : get_buf_size(scn, args, arg_info));
+                    
+                    if (is_valid_address(buf_ptr, buf_size) && buf_size) {
+                        if (GET_ARG_BUF_TYPE(arg_info) > 0 && GET_ARG_BUF_TYPE(arg_info) == ARG_TYPE_ATTR) {
+                            uint32_t num_args = 0;
+                            size_t data_size = 0;
+                            size_t data_offset = 0;
+
+                            struct utee_attribute attr = {0};
+
+                            buf_size = get_buf_size(scn, args, arg_info);
+                            num_args = buf_size / sizeof(struct utee_attribute);
+
+                            assert(buf_size % sizeof(struct utee_attribute) == 0);
+                            assert(num_args > 0);
+
+                            if (num_args > 1) /* TODO: multi attr support */
+                                num_args = 1;
+
+                            assert(tee_svc_copy_from_user(&attr, (void*)args[i], sizeof(attr)) == TEE_SUCCESS);
+
+                            if (is_valid_address(attr.a, attr.b) && attr.b) {
+                                SET_ARG_TYPE(cmd_arg_type, i, ARG_TEE_ATTR);
+                            }
+                            else { /* TODO: support attr without addresses */
+                                EMSG("Ignore invalid attr address: %p:%x", buf_ptr, buf_size);
+
+                                SET_ARG_TYPE(cmd_arg_type, i, ARG_VALUE_32);
+                            }
+                        }
+                        // Did we see this buffer before?
+                        else if (has_buffer(ctx, (void*)args[i], buf_size)) {
+                            SET_ARG_TYPE(cmd_arg_type, i, ARG_BUFFER_REF);
+                        }
+                        else {
+                            SET_ARG_TYPE(cmd_arg_type, i, ARG_DATA_PRIVATE);
+                        }
+                    }
+                    else {
+                        EMSG("Ignore invalid address: %p:%x", buf_ptr, buf_size);
+
+                        SET_ARG_TYPE(cmd_arg_type, i, ARG_VALUE_32);
+                    }
+                }
+                break;
+
+            default:
+                assert(0);
+        }
+    }
+
+    return cmd_arg_type;
+}
+
+static void append_cmd(struct afl_svc_trace_ctx* ctx, uint64_t scn, uint64_t* args) {
+    uint32_t cmd_arg_type = determine_arg_type(ctx, scn, args);
+
+    uintptr_t cmd_buff_size = (uintptr_t)ctx->cmd_buf_last_append_p - (uintptr_t)ctx->cmd_buf;
+
+    if (cmd_buff_size > 1024) { // Max 1 kb of commands
+        return;
+    }
+
+    ctx->cmd_buf = realloc(ctx->cmd_buf, cmd_buff_size + max_invoke_entry_size());
+
+    assert(ctx->cmd_buf != NULL);
+
+    ctx->cmd_buf_last_append_p = (uintptr_t)ctx->cmd_buf + cmd_buff_size;
+    ctx->cmd_buf_last_p = ctx->cmd_buf_last_append_p;
+
+    CMD_BUF_APPEND(ctx->cmd_buf_last_append_p, scn, cmd_arg_type);
+
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        uint64_t arg_info = syscall_arg_info(scn, i);
+        uint32_t arg_type = GET_ARG_TYPE(cmd_arg_type, i);
+
+        switch (arg_type) {
+            case ARG_NONE:
+            case ARG_VALUE_NULL:
+                break;
+
+            case ARG_VALUE_32:
+                CMD_BUF_APPEND_ARG_VALUE32(ctx->cmd_buf_last_append_p, args[i]);
+                break;
+
+            case ARG_BUFFER_DEREF32:
+                {
+                    switch (arg_info & 0xFF) {
+                        case ARG_HANDLE:
+                            assert(has_handle(ctx, args[i]));
+
+                            CMD_BUF_APPEND_ARG_DEREF32(ctx->cmd_buf_last_append_p, lookup_handle_buffer_id(ctx, args[i]));
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+
+            case ARG_BUFFER_ALLOC:
+                { // Lookup buffer or assign a new one
+                    size_t buf_size;
+                    uint32_t buf_id;
+
+                    switch (arg_info & 0xFF) {
+                        case ARG_VALUE_INOUT_PTR:
+                        case ARG_VALUE_OUT_PTR:
+                        case ARG_HANDLE_OUT_PTR:
+                            buf_size = sizeof(uint64_t);
+
+                            assert(!has_buffer(ctx, (void*)args[i], buf_size));
+
+                            buf_id = assign_buffer_id(ctx, (void*)args[i], buf_size);
+
+                            CMD_BUF_APPEND_ARG_BUFFER_ALLOC(ctx->cmd_buf_last_append_p, buf_id, buf_size);
+                            break;
+
+                        case ARG_BUF_IN_ADDR:
+                        case ARG_BUF_INOUT_ADDR:
+                        case ARG_BUF_OUT_ADDR:
+                            buf_size = get_buf_size(scn, args, arg_info);
+
+                            assert(!has_buffer(ctx, (void*)args[i], buf_size));
+
+                            buf_id = assign_buffer_id(ctx, (void*)args[i], buf_size);
+
+                            CMD_BUF_APPEND_ARG_BUFFER_ALLOC(ctx->cmd_buf_last_append_p, buf_id, buf_size);
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+
+            case ARG_BUFFER_REF:
+                { // Lookup buffer or assign a new one
+                    size_t buf_size;
+
+                    switch (arg_info & 0xFF) {
+                        case ARG_VALUE_INOUT_PTR:
+                        case ARG_VALUE_OUT_PTR:
+                        case ARG_HANDLE_OUT_PTR:
+                            buf_size = sizeof(uint64_t);
+
+                            assert(has_buffer(ctx, (void*)args[i], buf_size));
+
+                            CMD_BUF_APPEND_ARG_BUFFER_REF(ctx->cmd_buf_last_append_p, lookup_buffer_id(ctx, (void*)args[i], buf_size), buf_size);
+                            break;
+
+                        case ARG_BUF_IN_ADDR:
+                        case ARG_BUF_INOUT_ADDR:
+                        case ARG_BUF_OUT_ADDR:
+                            buf_size = get_buf_size(scn, args, arg_info);
+
+                            assert(has_buffer(ctx, (void*)args[i], buf_size));
+
+                            CMD_BUF_APPEND_ARG_BUFFER_REF(ctx->cmd_buf_last_append_p, lookup_buffer_id(ctx, (void*)args[i], buf_size), buf_size);
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+
+            case ARG_DATA_PRIVATE:
+                { // Copy data + set offset
+                    size_t data_size = 0;
+                    size_t data_offset = 0;
+
+                    assert(args[i] != NULL);
+
+                    switch (arg_info & 0xFF) {
+                        case ARG_VALUE_INOUT_PTR:
+                            data_size = sizeof(uint64_t);
+
+                            data_offset = DATA_BUF_APPEND(ctx->data_buf, (void*)args[i], data_size);
+
+                            CMD_BUF_APPEND_ARG_DATA(ctx->cmd_buf_last_append_p, data_offset, data_size);
+                            break;
+
+                        case ARG_BUF_IN_ADDR:
+                        case ARG_BUF_INOUT_ADDR:
+                            data_size = get_buf_size(scn, args, arg_info);
+
+                            if (data_size > 512) // Even the biggest keys etc should fit in 512 bytes
+                                data_size = 512;
+
+                            data_offset = DATA_BUF_APPEND(ctx->data_buf, (void*)args[i], data_size);
+
+                            CMD_BUF_APPEND_ARG_DATA(ctx->cmd_buf_last_append_p, data_offset, data_size);
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+
+            case ARG_TEE_ATTR:
+                {
+                    uint32_t num_args = 0;
+                    size_t buf_size = 0;
+                    size_t data_size = 0;
+                    size_t data_offset = 0;
+
+                    struct utee_attribute attr = {0};
+
+                    switch (arg_info & 0xFF) {
+                        case ARG_BUF_IN_ADDR:
+                            buf_size = get_buf_size(scn, args, arg_info);
+                            num_args = buf_size / sizeof(struct utee_attribute);
+
+                            assert(buf_size % sizeof(struct utee_attribute) == 0);
+
+                            if (num_args > 1) /* TODO: multi attr support */
+                                num_args = 1;
+
+                            assert(tee_svc_copy_from_user(&attr, (void*)args[i], sizeof(attr)) == TEE_SUCCESS);
+
+                            data_size = attr.b;
+                            data_offset = DATA_BUF_APPEND(ctx->data_buf, attr.a, data_size);
+
+                            CMD_BUF_APPEND_ARG_TEE_ATTR(ctx->cmd_buf_last_append_p, attr.attribute_id, data_offset, data_size);
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+
+            default:
+                EMSG("Unexpected arg type: %x", arg_type);
+                assert(0);
+        }
+    }
+}  
+
+static void do_svc_log_call(struct afl_svc_trace_ctx* ctx, uint64_t scn, uint64_t* args) {
+    print_invoke_syscall_info(scn, args);
+
+    validate_args(scn, args);
+
+    append_cmd(ctx, scn, args);
+}
+
+static void do_svc_log_call_post(struct afl_svc_trace_ctx* ctx, uint64_t scn, const uint64_t* args, uint32_t ret_val) {
+    print_post_invoke_syscall_info(scn, args, ret_val);
+
+    if (ret_val == TEE_SUCCESS) {
+        track_created_handles(ctx, scn, args);
+    }
+}
+
+static uint64_t get_reg_val(const struct thread_svc_regs *regs, uint32_t reg_nr) {
+    uint64_t val = 0;
+
+    switch (reg_nr) {
+        #define __SW_CASE(n) \
+                case n: \
+                    val = regs->x ## n; \
+                    break;
+
+        __SW_CASE(0);
+        __SW_CASE(1);
+        __SW_CASE(2);
+        __SW_CASE(3);
+        __SW_CASE(4);
+        __SW_CASE(5);
+        __SW_CASE(6);
+        __SW_CASE(7);
+
+        default:
+            assert(0);
+    }
+
+    return val;
+}
+
+// Use this instead of get_reg_val with 32-bit TAs
+static uint64_t ta32_get_arg_val(const struct thread_svc_regs *regs, uint32_t reg_nr) {
+    if (reg_nr < 4) { // First 4 arguments are passed as registers 
+        return get_reg_val(regs, reg_nr);
+    }
+
+    uint32_t stack_args = regs->x6;
+    uint32_t* stack_args_ptr = (uint32_t*)regs->x5;
+
+    if (reg_nr > stack_args + 4) {
+        EMSG("get_arg_val(%i) but %i arguments provided on the stack", reg_nr, stack_args);
+        panic();
+    }
+
+    return stack_args_ptr[reg_nr - 4];
+}
+
+static bool is_svc_ignored(uint64_t scn) {
+    switch (scn) {
+        case TEE_SCN_RETURN:
+        case TEE_SCN_PANIC:
+        case TEE_SCN_LOG:
+        case TEE_SCN_WAIT:
+
+        case TEE_SCN_OPEN_TA_SESSION:
+        case TEE_SCN_CLOSE_TA_SESSION:
+        case TEE_SCN_INVOKE_TA_COMMAND:
+
+        /* too noisy for demos */
+        case TEE_SCN_CRYP_OBJ_GET_INFO:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
+/* Called from arch_svc.c */
+void __afl_svc_trace_log_call(uint64_t scn, struct thread_svc_regs *regs, uint64_t* args) {
+    struct tee_ta_session *sess;
+
+    assert(tee_ta_get_current_session(&sess) == TEE_SUCCESS);
+
+    if (sess->svc_trace_ctx != NULL && sess->svc_trace_ctx->trace_enabled) {
+        if (!is_svc_ignored(scn)) {
+            for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+                args[i] = get_reg_val(regs, i);
+            }
+
+            do_svc_log_call(sess->svc_trace_ctx, scn, args);
+        }
+    }
+}
+
+void __afl_svc_trace_log_call_post(uint64_t scn, const struct thread_svc_regs *regs, const uint64_t* args) {
+    struct tee_ta_session *sess;
+
+    assert(tee_ta_get_current_session(&sess) == TEE_SUCCESS);
+
+    if (sess->svc_trace_ctx != NULL && sess->svc_trace_ctx->trace_enabled) {
+        if (!is_svc_ignored(scn)) {
+            do_svc_log_call_post(sess->svc_trace_ctx, scn, args, regs->x0);
+        }
+    }
+}
+
+static inline void update_data_offsets(void* buf, uint32_t buf_len, uint32_t data_offset) {
+    CTX ctx = {
+        .buf = buf,
+        .buf_len = buf_len,
+
+        .cmd_first = buf,
+        .cmd_current = NULL,
+
+        .data = buf,
+        .data_len = buf_len,
+
+        .p_error = NULL
+    };
+
+    while (CMD_NEXT(&ctx) != NULL) {
+        const SYSCALL_INVOKE* const sys_invoke_p = CMD_CURRENT(&ctx);
+
+        SVC_FOREACH_ARG(sys_invoke_p, 0, syscall_num_args(sys_invoke_p->nr), p_arg, arg_type, {
+            switch (arg_type) {
+                case ARG_DATA_SHARED:
+                case ARG_DATA_PRIVATE:
+                    ((SYSCALL_ARG*)p_arg)->data.offset += data_offset;
+                    break;
+
+                case ARG_TEE_ATTR:
+                    ((SYSCALL_ARG*)p_arg)->tee_attr.offset += data_offset;
+                    break;
+
+                default:
+                    break;
+            }
+        });
+    }
+}
+
+/* entry_std.c */
+extern struct tee_ta_session_head tee_open_sessions;
+
+/* Called by AFL-TEE PTA */
+TEE_Result afl_svc_trace_start(uint32_t session_id) {
+    struct tee_ta_session* sess = tee_ta_get_session(session_id, true, &tee_open_sessions);
+
+    if (sess == NULL)
+        return TEE_ERROR_BAD_PARAMETERS;
+
+    EMSG("Start tracing... (sess_id: %x)", session_id);
+
+    if (!sess->svc_trace_ctx) {
+        sess->svc_trace_ctx = (struct afl_svc_trace_ctx*)malloc(sizeof(struct afl_svc_trace_ctx));
+
+        memset(sess->svc_trace_ctx, 0, sizeof(struct afl_svc_trace_ctx));
+    }
+
+    struct afl_svc_trace_ctx* ctx = sess->svc_trace_ctx;
+
+    assert(ctx != NULL);
+    assert(!ctx->trace_enabled);
+
+    ctx->trace_enabled = true;
+
+    tee_ta_put_session(sess);
+
+    return TEE_SUCCESS;
+}
+
+TEE_Result afl_svc_trace_stop(uint32_t session_id, void* dst, uint32_t* dst_len) {
+    struct tee_ta_session* sess = tee_ta_get_session(session_id, true, &tee_open_sessions);
+
+    if (sess == NULL)
+        return TEE_ERROR_BAD_PARAMETERS;
+
+    EMSG("Stop tracing... (sess_id: %x)", session_id);
+
+    struct afl_svc_trace_ctx* ctx = sess->svc_trace_ctx;
+
+    assert(ctx != NULL);
+    assert(ctx->trace_enabled);
+
+    ctx->trace_enabled = false;
+
+    if (CMD_BUF_SIZE(ctx->cmd_buf)) {
+        assert(ctx->cmd_buf != NULL);
+        assert(ctx->cmd_buf_last_append_p != NULL);
+
+        // Terminate command buffer
+        CMD_BUF_APPEND(ctx->cmd_buf_last_append_p, 0xFF, 0);
+
+        size_t cmd_len = CMD_BUF_SIZE(ctx->cmd_buf);
+        size_t data_len = DATA_BUF_SIZE(ctx->data_buf);
+
+        EMSG("Cmd len %x Data len %x", cmd_len, data_len);
+
+        if (cmd_len + data_len > *dst_len) {
+            return TEE_ERROR_BAD_PARAMETERS;
+        }
+
+        update_data_offsets(ctx->cmd_buf, cmd_len, cmd_len);
+
+        memcpy(dst, ctx->cmd_buf, cmd_len);
+
+        if (data_len) {
+            assert(ctx->data_buf != NULL);
+
+            memcpy((void*)((uintptr_t) dst + cmd_len), ctx->data_buf, data_len);
+        }
+
+        *dst_len = cmd_len + data_len;
+    }
+    else {
+        *dst_len = 0;
+    }
+
+    tee_ta_put_session(sess);
+
+    return TEE_SUCCESS;
+}
+
+TEE_Result afl_trace_init(void)
+{
+    __cache_data();
+
+    return TEE_SUCCESS;
+}
+
+driver_init(afl_trace_init);
\ No newline at end of file
diff --git a/core/arch/arm/arm.mk b/core/arch/arm/arm.mk
index 7e15ae1..a04faff 100644
--- a/core/arch/arm/arm.mk
+++ b/core/arch/arm/arm.mk
@@ -107,7 +107,7 @@ CFG_CC_OPTIMIZE_FOR_SIZE ?= y
 ifeq ($(CFG_CC_OPTIMIZE_FOR_SIZE),y)
 platform-cflags-optimization ?= -Os
 else
-platform-cflags-optimization ?= -O0
+platform-cflags-optimization ?= -O3
 endif
 
 CFG_DEBUG_INFO ?= y

diff --git a/core/arch/arm/kernel/kern.ld.S b/core/arch/arm/kernel/kern.ld.S
index f37e015..4bd65c6 100644
--- a/core/arch/arm/kernel/kern.ld.S
+++ b/core/arch/arm/kernel/kern.ld.S
@@ -496,3 +496,6 @@ __asan_map_end = ((__asan_shadow_end - 1) / SMALL_PAGE_SIZE) *
 		 SMALL_PAGE_SIZE + SMALL_PAGE_SIZE;
 __asan_map_size = __asan_map_end - __asan_map_start;
 #endif /*CFG_CORE_SANITIZE_KADDRESS*/
+
+__afl_text_start = __text_start;
+__afl_text_end = __text_end;
\ No newline at end of file
diff --git a/core/arch/arm/kernel/link_dummy.ld b/core/arch/arm/kernel/link_dummy.ld
index 15ed19d..c752778 100644
--- a/core/arch/arm/kernel/link_dummy.ld
+++ b/core/arch/arm/kernel/link_dummy.ld
@@ -77,3 +77,6 @@ PROVIDE(core_v_str = 0);
 PROVIDE(tee_entry_std = 0);
 PROVIDE(tee_svc_handler = 0);
 PROVIDE(init_teecore = 0);
+
+__afl_text_start = .;
+__afl_text_end = .;
diff --git a/core/arch/arm/kernel/ree_fs_ta.c b/core/arch/arm/kernel/ree_fs_ta.c
index 5ac027c..1e2120e 100644
--- a/core/arch/arm/kernel/ree_fs_ta.c
+++ b/core/arch/arm/kernel/ree_fs_ta.c
@@ -85,8 +85,10 @@ static TEE_Result ta_open(const TEE_UUID *uuid,
 	struct user_ta_store_handle *handle;
 	struct shdr *shdr = NULL;
 	struct mobj *mobj = NULL;
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	void *hash_ctx = NULL;
 	uint32_t hash_algo = 0;
+#endif
 	struct shdr *ta = NULL;
 	size_t ta_size = 0;
 	uint64_t cookie = 0;
@@ -122,6 +124,7 @@ static TEE_Result ta_open(const TEE_UUID *uuid,
 	 * Initialize a hash context and run the algorithm over the signed
 	 * header (less the final file hash and its signature of course)
 	 */
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	hash_algo = TEE_DIGEST_HASH_TO_ALGO(shdr->algo);
 	res = crypto_hash_alloc_ctx(&hash_ctx, hash_algo);
 	if (res != TEE_SUCCESS)
@@ -133,6 +136,8 @@ static TEE_Result ta_open(const TEE_UUID *uuid,
 				     sizeof(*shdr));
 	if (res != TEE_SUCCESS)
 		goto error_free_hash;
+#endif
+
 	offs = SHDR_GET_SIZE(shdr);
 
 	if (shdr->img_type == SHDR_BOOTSTRAP_TA) {
@@ -156,10 +161,13 @@ static TEE_Result ta_open(const TEE_UUID *uuid,
 			goto error_free_hash;
 		}
 
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 		res = crypto_hash_update(hash_ctx, hash_algo,
 					 (uint8_t *)&bs_hdr, sizeof(bs_hdr));
 		if (res != TEE_SUCCESS)
 			goto error_free_hash;
+#endif
+
 		offs += sizeof(bs_hdr);
 	}
 
@@ -172,15 +180,19 @@ static TEE_Result ta_open(const TEE_UUID *uuid,
 	handle->nw_ta_size = ta_size;
 	handle->cookie = cookie;
 	handle->offs = offs;
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	handle->hash_algo = hash_algo;
 	handle->hash_ctx = hash_ctx;
+#endif
 	handle->shdr = shdr;
 	handle->mobj = mobj;
 	*h = handle;
 	return TEE_SUCCESS;
 
 error_free_hash:
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	crypto_hash_free_ctx(hash_ctx, hash_algo);
+#endif
 error_free_payload:
 	thread_rpc_free_payload(cookie, mobj);
 error:
@@ -230,10 +242,13 @@ static TEE_Result ta_read(struct user_ta_store_handle *h, void *data,
 		dst = data; /* Hash secure buffer (shm might be modified) */
 		memcpy(dst, src, len);
 	}
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	res = crypto_hash_update(h->hash_ctx, h->hash_algo, dst, len);
 	if (res != TEE_SUCCESS)
 		return TEE_ERROR_SECURITY;
+#endif
 	h->offs += len;
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	if (h->offs == h->nw_ta_size) {
 		/*
 		 * Last read: time to check if our digest matches the expected
@@ -242,6 +257,9 @@ static TEE_Result ta_read(struct user_ta_store_handle *h, void *data,
 		res = check_digest(h);
 	}
 	return res;
+#else
+	return TEE_SUCCESS;
+#endif
 }
 
 static void ta_close(struct user_ta_store_handle *h)
@@ -249,7 +267,9 @@ static void ta_close(struct user_ta_store_handle *h)
 	if (!h)
 		return;
 	thread_rpc_free_payload(h->cookie, h->mobj);
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	crypto_hash_free_ctx(h->hash_ctx, h->hash_algo);
+#endif
 	free(h->shdr);
 	free(h);
 }
diff --git a/core/arch/arm/kernel/sub.mk b/core/arch/arm/kernel/sub.mk
index 8754d70..2a4afb4 100644
--- a/core/arch/arm/kernel/sub.mk
+++ b/core/arch/arm/kernel/sub.mk
@@ -57,3 +57,25 @@ endif
 srcs-y += link_dummies.c
 
 asm-defines-y += asm-defines.c
+
+cflags-y += -fno-sanitize=all
+
+cflags-remove-abort.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-early_ta.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-elf_load.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-elf_load_dyn.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-mutex.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-pseudo_ta.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-ree_fs_ta.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-secstor_ta.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-spin_lock_debug.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-tee_time.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-tee_time_arm_cntpct.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-tee_time_ree.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-thread.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-trace_ext.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-unwind_arm32.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-unwind_arm64.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-user_ta.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-vfp.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-wait_queue.c-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/core/arch/arm/kernel/thread.c b/core/arch/arm/kernel/thread.c
index 634581e..2b9e5fe 100644
--- a/core/arch/arm/kernel/thread.c
+++ b/core/arch/arm/kernel/thread.c
@@ -9,6 +9,7 @@
 #include <arm.h>
 #include <assert.h>
 #include <keep.h>
+#include <kernel/afl.h>
 #include <kernel/asan.h>
 #include <kernel/misc.h>
 #include <kernel/msg_param.h>
@@ -716,8 +717,19 @@ static void release_unused_kernel_stack(struct thread_ctx *thr __unused,
 }
 #endif
 
+__attribute__( ( always_inline ) ) static inline uint32_t __get_LR(void) {
+    register uintptr_t result;
+
+    __asm volatile ("mov %0, x30\n" : "=r" (result) );
+
+    return(result);
+}
+
 int thread_state_suspend(uint32_t flags, uint32_t cpsr, vaddr_t pc)
 {
+	//EMSG("Suspend LR: %p", __get_LR());
+	__afl_thread_suspend();
+
 	struct thread_core_local *l = thread_get_core_local();
 	int ct = l->curr_thread;
 
diff --git a/core/arch/arm/kernel/thread_a64.S b/core/arch/arm/kernel/thread_a64.S
index c9e284f..e139a00 100644
--- a/core/arch/arm/kernel/thread_a64.S
+++ b/core/arch/arm/kernel/thread_a64.S
@@ -20,7 +20,7 @@
 	.macro get_thread_ctx core_local, res, tmp0, tmp1
 		ldr	w\tmp0, [\core_local, \
 				#THREAD_CORE_LOCAL_CURR_THREAD]
-		adr	x\res, threads
+		ldr	x\res, =threads
 		mov	x\tmp1, #THREAD_CTX_SIZE
 		madd	x\res, x\tmp0, x\tmp1, x\res
 	.endm
@@ -34,6 +34,9 @@
 LOCAL_FUNC vector_std_smc_entry , :
 	sub	sp, sp, #THREAD_SMC_ARGS_SIZE
 	store_xregs sp, THREAD_SMC_ARGS_X0, 0, 7
+
+	bl __afl_reset_thread_ctx
+
 	mov	x0, sp
 	bl	thread_handle_std_smc
 	/*
@@ -52,6 +55,9 @@ END_FUNC vector_std_smc_entry
 LOCAL_FUNC vector_fast_smc_entry , :
 	sub	sp, sp, #THREAD_SMC_ARGS_SIZE
 	store_xregs sp, THREAD_SMC_ARGS_X0, 0, 7
+
+	bl __afl_reset_thread_ctx
+
 	mov	x0, sp
 	bl	thread_handle_fast_smc
 	load_xregs sp, THREAD_SMC_ARGS_X0, 1, 8
@@ -63,8 +69,11 @@ END_FUNC vector_fast_smc_entry
 
 LOCAL_FUNC vector_fiq_entry , :
 	/* Secure Monitor received a FIQ and passed control to us. */
+
+	bl __afl_reset_thread_ctx
+
 	bl	thread_check_canaries
-	adr	x16, thread_nintr_handler_ptr
+	ldr	x16, =thread_nintr_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	ldr	x0, =TEESMC_OPTEED_RETURN_FIQ_DONE
@@ -73,7 +82,9 @@ LOCAL_FUNC vector_fiq_entry , :
 END_FUNC vector_fiq_entry
 
 LOCAL_FUNC vector_cpu_on_entry , :
-	adr	x16, thread_cpu_on_handler_ptr
+	bl __afl_reset_thread_ctx
+
+	ldr	x16, =thread_cpu_on_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -83,7 +94,7 @@ LOCAL_FUNC vector_cpu_on_entry , :
 END_FUNC vector_cpu_on_entry
 
 LOCAL_FUNC vector_cpu_off_entry , :
-	adr	x16, thread_cpu_off_handler_ptr
+	ldr	x16, =thread_cpu_off_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -93,7 +104,7 @@ LOCAL_FUNC vector_cpu_off_entry , :
 END_FUNC vector_cpu_off_entry
 
 LOCAL_FUNC vector_cpu_suspend_entry , :
-	adr	x16, thread_cpu_suspend_handler_ptr
+	ldr	x16, =thread_cpu_suspend_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -103,7 +114,9 @@ LOCAL_FUNC vector_cpu_suspend_entry , :
 END_FUNC vector_cpu_suspend_entry
 
 LOCAL_FUNC vector_cpu_resume_entry , :
-	adr	x16, thread_cpu_resume_handler_ptr
+	bl __afl_reset_thread_ctx
+
+	ldr	x16, =thread_cpu_resume_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -113,7 +126,7 @@ LOCAL_FUNC vector_cpu_resume_entry , :
 END_FUNC vector_cpu_resume_entry
 
 LOCAL_FUNC vector_system_off_entry , :
-	adr	x16, thread_system_off_handler_ptr
+	ldr	x16, =thread_system_off_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -123,7 +136,7 @@ LOCAL_FUNC vector_system_off_entry , :
 END_FUNC vector_system_off_entry
 
 LOCAL_FUNC vector_system_reset_entry , :
-	adr	x16, thread_system_reset_handler_ptr
+	ldr	x16, =thread_system_reset_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -155,6 +168,10 @@ KEEP_PAGER thread_vector_table
 
 /* void thread_resume(struct thread_ctx_regs *regs) */
 FUNC thread_resume , :
+	mov x20, x0
+	bl __afl_thread_resume
+	mov x0, x20
+
 	load_xregs x0, THREAD_CTX_REGS_SP, 1, 3
 	load_xregs x0, THREAD_CTX_REGS_X4, 4, 30
 	mov	sp, x1
@@ -409,18 +426,21 @@ FUNC thread_excp_vect , :
 	.align	7, INV_INSN
 el1_sync_sp0:
 	store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 3
+	
 	b	el1_sync_abort
 	check_vector_size el1_sync_sp0
 
 	.align	7, INV_INSN
 el1_irq_sp0:
 	store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 3
+	
 	b	elx_irq
 	check_vector_size el1_irq_sp0
 
 	.align	7, INV_INSN
 el1_fiq_sp0:
 	store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 3
+	
 	b	elx_fiq
 	check_vector_size el1_fiq_sp0
 
@@ -1055,7 +1075,7 @@ END_FUNC el0_sync_abort
 	stp	x30, x2, [sp, #ELX_NINTR_REC_LR]
 
 	bl	thread_check_canaries
-	adr	x16, thread_nintr_handler_ptr
+	ldr	x16, =thread_nintr_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 
diff --git a/core/arch/arm/mm/sub.mk b/core/arch/arm/mm/sub.mk
index 3885352..3ca4561 100644
--- a/core/arch/arm/mm/sub.mk
+++ b/core/arch/arm/mm/sub.mk
@@ -9,3 +9,6 @@ endif
 srcs-y += tee_mm.c
 srcs-y += pgt_cache.c
 srcs-y += mobj.c
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/core/arch/arm/plat-vexpress/conf.mk b/core/arch/arm/plat-vexpress/conf.mk
index 9144280..34067dc 100644
--- a/core/arch/arm/plat-vexpress/conf.mk
+++ b/core/arch/arm/plat-vexpress/conf.mk
@@ -108,4 +108,5 @@ CFG_SHMEM_SIZE  ?= 0x00200000
 # When Secure Data Path is enable, last MByte of TZDRAM is SDP test memory.
 CFG_TEE_SDP_MEM_SIZE ?= 0x00400000
 $(call force,CFG_DT,y)
+CFG_TEE_RAM_VA_SIZE ?= 0x00400000
 endif
diff --git a/core/arch/arm/pta/sub.mk b/core/arch/arm/pta/sub.mk
index 029f9be..b5ecd34 100644
--- a/core/arch/arm/pta/sub.mk
+++ b/core/arch/arm/pta/sub.mk
@@ -16,3 +16,8 @@ ifeq ($(CFG_SE_API),y)
 srcs-$(CFG_SE_API_SELF_TEST) += se_api_self_tests.c
 cppflags-se_api_self_tests.c-y += -Icore/tee/se
 endif
+
+srcs-y += afl.c
+
+cflags-afl.c-y += -fno-sanitize=all
+cflags-remove-afl.c-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/core/arch/arm/tee/arch_svc.c b/core/arch/arm/tee/arch_svc.c
index b2dd193..fc1b62f 100644
--- a/core/arch/arm/tee/arch_svc.c
+++ b/core/arch/arm/tee/arch_svc.c
@@ -1,3 +1,4 @@
+
 // SPDX-License-Identifier: BSD-2-Clause
 /*
  * Copyright (c) 2014, Linaro Limited
@@ -43,6 +44,15 @@ struct syscall_entry {
 #define SYSCALL_ENTRY(_fn) { .fn = (syscall_t)_fn }
 #endif
 
+#ifdef CFG_AFL_ENABLE
+#define AFL_SYSCALLS 2
+
+#include <kernel/afl.h>
+
+#else
+#define AFL_SYSCALLS 0
+#endif
+
 /*
  * This array is ordered according to the SYSCALL ids TEE_SCN_xxx
  */
@@ -118,6 +128,14 @@ static const struct syscall_entry tee_svc_syscall_table[] = {
 	SYSCALL_ENTRY(syscall_se_channel_transmit),
 	SYSCALL_ENTRY(syscall_se_channel_close),
 	SYSCALL_ENTRY(syscall_cache_operation),
+
+#ifdef CFG_AFL_ENABLE
+
+	SYSCALL_ENTRY(syscall_afl_cov_bitmap_init),
+	//SYSCALL_ENTRY(__afl_bitmap_disable),
+	SYSCALL_ENTRY(syscall_afl_cov_bitmap_shutdown),
+
+#endif
 };
 
 #ifdef TRACE_SYSCALLS
@@ -171,6 +189,34 @@ static void set_svc_retval(struct thread_svc_regs *regs, uint64_t ret_val)
 }
 #endif /*ARM64*/
 
+#ifdef CFG_AFL_ENABLE
+// Called by tee_svc_handler just before it starts executing a syscall handler
+static inline void __afl_cov_trace_start(struct tee_ta_session *sess) {
+    assert(sess->afl_ctx != NULL);
+    assert(__afl_ctx_ptr() == NULL);
+
+    sess->afl_ctx->prev_loc = 0;
+
+    __afl_set_ctx_ptr(sess->afl_ctx);
+
+    sess->afl_ctx->enabled = true;
+}
+
+// Called by tee_svc_handler just after it finished executing a syscall handler
+static inline void __afl_cov_trace_stop(struct tee_ta_session *sess) {
+    assert(sess->afl_ctx != NULL);
+
+    if (sess->afl_ctx != __afl_ctx_ptr()) {
+        EMSG("ctx: %p != %p", sess->afl_ctx, __afl_ctx_ptr());
+        assert(sess->afl_ctx == __afl_ctx_ptr());
+    }
+
+    sess->afl_ctx->enabled = false;
+
+    __afl_set_ctx_ptr(0);   
+}
+#endif
+
 /*
  * Note: this function is weak just to make it possible to exclude it from
  * the unpaged area.
@@ -181,9 +227,10 @@ void __weak tee_svc_handler(struct thread_svc_regs *regs)
 	size_t max_args;
 	syscall_t scf;
 	uint32_t state;
+	uint32_t exceptions;
 
 	COMPILE_TIME_ASSERT(ARRAY_SIZE(tee_svc_syscall_table) ==
-				(TEE_SCN_MAX + 1));
+				(TEE_SCN_MAX + AFL_SYSCALLS + 1));
 
 	/* Enable native interupts */
 	state = thread_get_exceptions();
@@ -207,12 +254,47 @@ void __weak tee_svc_handler(struct thread_svc_regs *regs)
 		return;
 	}
 
-	if (scn > TEE_SCN_MAX)
+	if (scn > TEE_SCN_MAX + AFL_SYSCALLS)
 		scf = (syscall_t)syscall_not_supported;
 	else
 		scf = tee_svc_syscall_table[scn].fn;
 
+	// Disable interrupts
+	exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
+
+#ifdef CFG_AFL_ENABLE
+	struct tee_ta_session *sess;
+
+    assert(tee_ta_get_current_session(&sess) == TEE_SUCCESS);
+
+	if (scn <= TEE_SCN_MAX && sess->afl_ctx != NULL) { // Only trace when we have a bitmap and it's not an AFL syscall
+		if (scn != TEE_SCN_LOG) // We use log extensively in our TA
+			__afl_cov_trace_start(sess);
+
+		set_svc_retval(regs, tee_svc_do_call(regs, scf));
+
+		if (scn != TEE_SCN_LOG)
+			__afl_cov_trace_stop(sess);
+	}
+	else {
+		uint64_t args[TEE_SVC_MAX_ARGS];
+
+		if (scn <= TEE_SCN_MAX) { // Normals SVCs
+			__afl_svc_trace_log_call(scn, regs, &args);
+		}
+
+		set_svc_retval(regs, tee_svc_do_call(regs, scf));
+
+		if (scn <= TEE_SCN_MAX) {
+			__afl_svc_trace_log_call_post(scn, regs, &args);
+		}
+	}
+#else
 	set_svc_retval(regs, tee_svc_do_call(regs, scf));
+#endif
+
+	/* Restore interrupts */
+	thread_unmask_exceptions(exceptions);
 
 	if (scn != TEE_SCN_RETURN) {
 		/* We're about to switch back to user mode */
diff --git a/core/arch/arm/tee/entry_std.c b/core/arch/arm/tee/entry_std.c
index 92fdf0f..381e2b4 100644
--- a/core/arch/arm/tee/entry_std.c
+++ b/core/arch/arm/tee/entry_std.c
@@ -28,7 +28,7 @@
 	(uint32_t)(core_mmu_is_shm_cached() ?  OPTEE_SMC_SHM_CACHED : 0)
 
 /* Sessions opened from normal world */
-static struct tee_ta_session_head tee_open_sessions =
+struct tee_ta_session_head tee_open_sessions =
 TAILQ_HEAD_INITIALIZER(tee_open_sessions);
 
 static struct mobj *shm_mobj;
diff --git a/core/arch/arm/tee/sub.mk b/core/arch/arm/tee/sub.mk
index 0358324..0eb0db0 100644
--- a/core/arch/arm/tee/sub.mk
+++ b/core/arch/arm/tee/sub.mk
@@ -12,3 +12,6 @@ srcs-y += entry_fast.c
 cppflags-entry_fast.c-y += -DTEE_IMPL_GIT_SHA1=$(TEE_IMPL_GIT_SHA1)
 srcs-y += init.c
 srcs-y += cache.c
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/core/core.mk b/core/core.mk
index c9e82b9..f1a2aba 100644
--- a/core/core.mk
+++ b/core/core.mk
@@ -28,7 +28,7 @@ cppflags$(sm)	+= -I$(out-dir)/core/include
 cppflags$(sm)	+= $(core-platform-cppflags)
 cflags$(sm)	+= $(core-platform-cflags)
 ifeq ($(CFG_CORE_SANITIZE_UNDEFINED),y)
-cflags$(sm)	+= -fsanitize=undefined
+#cflags$(sm)	+= -fsanitize=undefined
 endif
 ifeq ($(CFG_CORE_SANITIZE_KADDRESS),y)
 ifeq ($(CFG_ASAN_SHADOW_OFFSET),)
diff --git a/core/crypto/rng_fortuna.c b/core/crypto/rng_fortuna.c
index b9ce2d2..6441ee7 100644
--- a/core/crypto/rng_fortuna.c
+++ b/core/crypto/rng_fortuna.c
@@ -301,14 +301,14 @@ void crypto_rng_add_event(enum crypto_rng_src sid, unsigned int *pnum,
 	unsigned int pn = get_next_pnum(pnum);
 	uint8_t snum = sid >> 1;
 
-	if (CRYPTO_RNG_SRC_IS_QUICK(sid)) {
-		push_ring_buffer(snum, pn, data, dlen);
-	} else {
-		mutex_lock(&state_mu);
-		add_event(snum, pn, data, dlen);
-		drain_ring_buffer();
-		mutex_unlock(&state_mu);
-	}
+	//if (CRYPTO_RNG_SRC_IS_QUICK(sid)) {
+	//	push_ring_buffer(snum, pn, data, dlen);
+	//} else {
+	//	mutex_lock(&state_mu);
+	//	add_event(snum, pn, data, dlen);
+	//	drain_ring_buffer();
+	//	mutex_unlock(&state_mu);
+	//}
 }
 
 /* GenerateBlocks */
diff --git a/core/crypto/signed_hdr.c b/core/crypto/signed_hdr.c
index 5b59c00..0d3c3b0 100644
--- a/core/crypto/signed_hdr.c
+++ b/core/crypto/signed_hdr.c
@@ -47,6 +47,7 @@ TEE_Result shdr_verify_signature(const struct shdr *shdr)
 	if (shdr->magic != SHDR_MAGIC)
 		return TEE_ERROR_SECURITY;
 
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	if (TEE_ALG_GET_MAIN_ALG(shdr->algo) != TEE_MAIN_ALGO_RSA)
 		return TEE_ERROR_SECURITY;
 
@@ -76,5 +77,6 @@ out:
 	crypto_acipher_free_rsa_public_key(&key);
 	if (res)
 		return TEE_ERROR_SECURITY;
+#endif
 	return TEE_SUCCESS;
 }
diff --git a/core/crypto/sub.mk b/core/crypto/sub.mk
index bb16a3e..887bc8e 100644
--- a/core/crypto/sub.mk
+++ b/core/crypto/sub.mk
@@ -13,3 +13,5 @@ srcs-y += rng_fortuna.c
 else
 srcs-y += rng_hw.c
 endif
+
+cflags-remove-signed_hdr.c-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/core/drivers/sub.mk b/core/drivers/sub.mk
index b2bcf15..13c09e6 100644
--- a/core/drivers/sub.mk
+++ b/core/drivers/sub.mk
@@ -20,3 +20,6 @@ srcs-$(CFG_STIH_UART) += stih_asc.c
 srcs-$(CFG_ATMEL_UART) += atmel_uart.c
 srcs-$(CFG_MVEBU_UART) += mvebu_uart.c
 srcs-$(CFG_STM32_UART) += stm32_uart.c
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/core/include/kernel/tee_ta_manager.h b/core/include/kernel/tee_ta_manager.h
index e4e66c8..5d484b2 100644
--- a/core/include/kernel/tee_ta_manager.h
+++ b/core/include/kernel/tee_ta_manager.h
@@ -104,6 +104,11 @@ struct tee_ta_session {
 #if defined(CFG_TA_GPROF_SUPPORT)
 	struct sample_buf *sbuf; /* Profiling data (PC sampling) */
 #endif
+
+#if defined(CFG_AFL_ENABLE)
+	struct afl_ctx* afl_ctx; 
+	struct afl_svc_trace_ctx* svc_trace_ctx; 
+#endif
 };
 
 /* Registered contexts */
diff --git a/core/kernel/assert.c b/core/kernel/assert.c
index d8c2348..59b42bc 100644
--- a/core/kernel/assert.c
+++ b/core/kernel/assert.c
@@ -8,6 +8,8 @@
 #include <trace.h>
 #include <kernel/panic.h>
 
+#include <kernel/afl.h>
+
 /* assert log and break for the optee kernel */
 
 void _assert_log(const char *expr __maybe_unused,
@@ -15,6 +17,9 @@ void _assert_log(const char *expr __maybe_unused,
 		 const int line __maybe_unused,
 		 const char *func __maybe_unused)
 {
+	// Set thread info registers to default values
+    __afl_set_ctx_ptr(0);
+
 #if defined(CFG_TEE_CORE_DEBUG)
 	EMSG_RAW("assertion '%s' failed at %s:%d <%s>",
 		 expr, file, line, func);
diff --git a/core/kernel/panic.c b/core/kernel/panic.c
index 37e30a8..36af5e0 100644
--- a/core/kernel/panic.c
+++ b/core/kernel/panic.c
@@ -8,11 +8,81 @@
 #include <kernel/thread.h>
 #include <trace.h>
 
 void __do_panic(const char *file __maybe_unused,
 		const int line __maybe_unused,
 		const char *func __maybe_unused,
 		const char *msg __maybe_unused)
 {
+	// Set thread info registers to default values
+    __afl_set_ctx_ptr(0);
+
 	/* disable prehemption */
 	(void)thread_mask_exceptions(THREAD_EXCP_ALL);
 
@@ -29,6 +99,17 @@ void __do_panic(const char *file __maybe_unused,
 
 	EPRINT_STACK();
 	/* abort current execution */
+
+	struct tee_ta_session *sess;
+
+    //EMSG("Resume: tee_ta_get_current_session(&sess) == TEE_SUCCESS: %x", tee_ta_get_current_session(&sess) == TEE_SUCCESS);    
+
+    if (tee_ta_get_current_session(&sess) == TEE_SUCCESS && sess->afl_ctx && sess->afl_ctx->enabled) {
+    	EMSG_RAW("AFL Input:");
+        //hexdump(sess->afl_ctx->input, sess->afl_ctx->input_len);
+        dhex_dump(NULL, 0, 0, sess->afl_ctx->input, sess->afl_ctx->input_len);
+    }
+
 	while (1)
 		;
 }
diff --git a/core/kernel/sub.mk b/core/kernel/sub.mk
index 41be95f..6374ee8 100644
--- a/core/kernel/sub.mk
+++ b/core/kernel/sub.mk
@@ -11,3 +11,35 @@ srcs-$(CFG_CORE_SANITIZE_UNDEFINED) += ubsan.c
 srcs-$(CFG_CORE_SANITIZE_KADDRESS) += asan.c
 cflags-remove-asan.c-y += $(cflags_kasan)
 srcs-y += refcount.c
+
+srcs-y += afl.c
+srcs-y += afl_svc_trace.c
+
+cflags-afl.c-y += -fno-sanitize=all
+cflags-asan.c-y += -fno-sanitize=all 
+cflags-assert.c-y += -fno-sanitize=all 
+cflags-console.c-y += -fno-sanitize=all 
+cflags-interrupt.c-y += -fno-sanitize=all 
+cflags-msg_param.c-y += -fno-sanitize=all 
+cflags-panic.c-y += -fno-sanitize=all 
+cflags-refcount.c-y += -fno-sanitize=all 
+cflags-tee_ta_manager.c-y += -fno-sanitize=all 
+cflags-ubsan.c-y += -fno-sanitize=all 
+
+cflags-afl_svc_trace.c-y += -I../afl-tee/shared/include
+cflags-afl_svc_trace.c-y += -Wno-pedantic -Wno-discarded-qualifiers -Wno-missing-prototypes -Wno-switch-default
+cflags-afl_svc_trace.c-y += -Wno-unused-parameter -Wno-missing-declarations -Wno-declaration-after-statement -Wno-format
+
+cflags-remove-afl.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-afl_svc_trace.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-asan.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-assert.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-console.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-interrupt.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-msg_param.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-panic.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-refcount.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-tee_misc.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-tee_ta_manager.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-ubsan.c-y += -fsanitize-coverage=trace-pc
+
diff --git a/core/kernel/tee_ta_manager.c b/core/kernel/tee_ta_manager.c
index 0a6c6ed..7164d11 100644
--- a/core/kernel/tee_ta_manager.c
+++ b/core/kernel/tee_ta_manager.c
@@ -19,6 +19,7 @@
 #include <kernel/tee_time.h>
 #include <kernel/thread.h>
 #include <kernel/user_ta.h>
+#include <kernel/afl.h>
 #include <mm/core_mmu.h>
 #include <mm/core_memprot.h>
 #include <mm/mobj.h>
@@ -406,9 +407,35 @@ TEE_Result tee_ta_close_session(struct tee_ta_session *csess,
 	}
 
 	tee_ta_unlink_session(sess, open_sessions);
+
 #if defined(CFG_TA_GPROF_SUPPORT)
 	free(sess->sbuf);
 #endif
+
+#if defined(CFG_AFL_ENABLE)
+	if (sess->afl_ctx) {
+		free(sess->afl_ctx);
+		
+		sess->afl_ctx = NULL;
+	}
+
+	if (sess->svc_trace_ctx) {
+		// log buffers
+		sess->svc_trace_ctx->cmd_buf = (sess->svc_trace_ctx->cmd_buf) ? free(sess->svc_trace_ctx->cmd_buf), NULL : NULL;
+		sess->svc_trace_ctx->data_buf = (sess->svc_trace_ctx->data_buf) ? free(sess->svc_trace_ctx->data_buf), NULL : NULL;
+
+		// buffer ids
+		sess->svc_trace_ctx->buf_ptrs = (sess->svc_trace_ctx->buf_ptrs) ? free(sess->svc_trace_ctx->buf_ptrs), NULL : NULL;
+		sess->svc_trace_ctx->buf_sizes = (sess->svc_trace_ctx->buf_sizes) ? free(sess->svc_trace_ctx->buf_sizes), NULL : NULL;
+
+		// handles
+		sess->svc_trace_ctx->handles = (sess->svc_trace_ctx->handles) ? free(sess->svc_trace_ctx->handles), NULL : NULL;
+		sess->svc_trace_ctx->handle_buf_ids = (sess->svc_trace_ctx->handle_buf_ids) ? free(sess->svc_trace_ctx->handle_buf_ids), NULL : NULL;
+
+		sess->svc_trace_ctx = (free(sess->svc_trace_ctx), NULL);
+	}
+#endif
+
 	free(sess);
 
 	tee_ta_clear_busy(ctx);
diff --git a/core/kernel/ubsan.c b/core/kernel/ubsan.c
index 04b0163..72ae682 100644
--- a/core/kernel/ubsan.c
+++ b/core/kernel/ubsan.c
@@ -28,6 +28,21 @@ struct type_mismatch_data {
 	unsigned char type_check_kind;
 };
 
+struct type_mismatch_data_v1 {
+	struct source_location loc;
+	struct type_descriptor *type;
+	unsigned char log_alignment;
+	unsigned char type_check_kind;
+};
+
+struct pointer_overflow_data {
+	struct source_location loc;
+};
+
+struct invalid_builtin_data {
+	struct source_location loc;
+};
+
 struct overflow_data {
 	struct source_location loc;
 	struct type_descriptor *type;
@@ -70,6 +85,11 @@ struct nonnull_arg_data {
  */
 void __ubsan_handle_type_mismatch(struct type_mismatch_data *data,
 				  unsigned long ptr);
+void __ubsan_handle_type_mismatch_v1(struct type_mismatch_data_v1 *data,
+				  unsigned long ptr __unused);
+void __ubsan_handle_pointer_overflow(struct pointer_overflow_data *data,
+				  unsigned long base __unused, unsigned long result __unused);
+void __ubsan_handle_invalid_builtin(struct invalid_builtin_data *data);
 void __ubsan_handle_add_overflow(struct overflow_data *data,
 				  unsigned long lhs, unsigned long rhs);
 void __ubsan_handle_sub_overflow(struct overflow_data *data,
@@ -119,6 +139,28 @@ void __ubsan_handle_type_mismatch(struct type_mismatch_data *data,
 		panic();
 }
 
+void __ubsan_handle_type_mismatch_v1(struct type_mismatch_data_v1 *data,
+				  unsigned long ptr __unused)
+{
+	print_loc(__func__, &data->loc);
+	if (ubsan_panic)
+		panic();
+}
+
+void __ubsan_handle_pointer_overflow(struct pointer_overflow_data *data,
+				  unsigned long base __unused, unsigned long result __unused)
+{
+	print_loc(__func__, &data->loc);
+	if (ubsan_panic)
+		panic();
+}
+
+void __ubsan_handle_invalid_builtin(struct invalid_builtin_data *data) {
+	print_loc(__func__, &data->loc);
+	if (ubsan_panic)
+		panic();
+}
+
 void __ubsan_handle_add_overflow(struct overflow_data *data,
 				 unsigned long lhs __unused,
 				 unsigned long rhs __unused)
diff --git a/core/tee/sub.mk b/core/tee/sub.mk
index eef6081..90d9359 100644
--- a/core/tee/sub.mk
+++ b/core/tee/sub.mk
@@ -48,3 +48,4 @@ srcs-y += uuid.c
 
 subdirs-$(CFG_SE_API) += se
 
+cflags-remove-uuid.c-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/lib/libmbedtls/sub.mk b/lib/libmbedtls/sub.mk
index 6f1fcfb..9ec2c43 100644
--- a/lib/libmbedtls/sub.mk
+++ b/lib/libmbedtls/sub.mk
@@ -84,4 +84,4 @@ srcs-y += $(addprefix mbedtls/library/, $(SRCS))
 
 cflags-lib-y += -Wno-redundant-decls
 cflags-lib-y += -Wno-switch-default
-cflags-lib-$(CFG_ULIBS_GPROF) += -pg
+cflags-lib-$(CFG_ULIBS_GPROF) += -pg
\ No newline at end of file
diff --git a/lib/libmpa/sub.mk b/lib/libmpa/sub.mk
index 2840f84..59726c1 100644
--- a/lib/libmpa/sub.mk
+++ b/lib/libmpa/sub.mk
@@ -41,4 +41,4 @@ srcs-y += mpa_init.c
 srcs-y += mpa_io.c
 srcs-y += mpa_modulus.c
 
-subdirs-$(arch_arm) += arch/$(ARCH)
+subdirs-$(arch_arm) += arch/$(ARCH)
\ No newline at end of file
diff --git a/lib/libutee/arch/arm/sub.mk b/lib/libutee/arch/arm/sub.mk
index f0c8e8a..cbc22a5 100644
--- a/lib/libutee/arch/arm/sub.mk
+++ b/lib/libutee/arch/arm/sub.mk
@@ -6,3 +6,5 @@ srcs-$(CFG_ARM32_$(sm)) += utee_syscalls_a32.S
 srcs-$(CFG_ARM64_$(sm)) += utee_syscalls_a64.S
 
 subdirs-y += gprof
+
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/lib/libutee/arch/arm/utee_syscalls_asm.S b/lib/libutee/arch/arm/utee_syscalls_asm.S
index b261597..f9efa1d 100644
--- a/lib/libutee/arch/arm/utee_syscalls_asm.S
+++ b/lib/libutee/arch/arm/utee_syscalls_asm.S
@@ -165,3 +165,8 @@
                 TEE_SCN_SE_CHANNEL_CLOSE, 1
 
         UTEE_SYSCALL utee_cache_operation, TEE_SCN_CACHE_OPERATION, 3
+
+//#if CFG_AFL_ENABLE
+        UTEE_SYSCALL utee_afl_cov_bitmap_init, (TEE_SCN_MAX+1), 0
+        UTEE_SYSCALL utee_afl_cov_bitmap_shutdown, (TEE_SCN_MAX+2), 0
+//#endif
\ No newline at end of file
diff --git a/lib/libutee/include/utee_syscalls.h b/lib/libutee/include/utee_syscalls.h
index 7fb2d1c..03e0556 100644
--- a/lib/libutee/include/utee_syscalls.h
+++ b/lib/libutee/include/utee_syscalls.h
@@ -278,4 +278,10 @@ TEE_Result utee_cache_operation(void *va, size_t l, unsigned long op);
 
 TEE_Result utee_gprof_send(void *buf, size_t size, uint32_t *id);
 
+#ifdef CFG_AFL_ENABLE
+void utee_afl_cov_bitmap_init(void* input, size_t input_len);
+//void utee_afl_bitmap_disable(void);
+void utee_afl_cov_bitmap_shutdown(void* ptr);
+#endif
+
 #endif /* UTEE_SYSCALLS_H */
diff --git a/lib/libutee/sub.mk b/lib/libutee/sub.mk
index 37ab8a2..1e64382 100644
--- a/lib/libutee/sub.mk
+++ b/lib/libutee/sub.mk
@@ -17,3 +17,5 @@ srcs-y += tee_socket_pta.c
 subdirs-y += arch/$(ARCH)
 
 cflags-lib-$(CFG_ULIBS_GPROF) += -pg
+
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/lib/libutils/ext/arch/arm/sub.mk b/lib/libutils/ext/arch/arm/sub.mk
index b10db0c..408f3e5 100644
--- a/lib/libutils/ext/arch/arm/sub.mk
+++ b/lib/libutils/ext/arch/arm/sub.mk
@@ -1,3 +1,6 @@
 srcs-$(CFG_ARM32_$(sm)) += aeabi_unwind.c
 srcs-$(CFG_ARM32_$(sm)) += atomic_a32.S
 srcs-$(CFG_ARM64_$(sm)) += atomic_a64.S
+
+cflags-y += -fno-sanitize=all 
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/lib/libutils/ext/sub.mk b/lib/libutils/ext/sub.mk
index fcded79..bdd3491 100644
--- a/lib/libutils/ext/sub.mk
+++ b/lib/libutils/ext/sub.mk
@@ -8,3 +8,6 @@ srcs-y += trace.c
 srcs-y += mempool.c
 
 subdirs-$(arch_arm) += arch/$(ARCH)
+
+cflags-y += -fno-sanitize=all 
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/lib/libutils/isoc/arch/arm/softfloat/source/sub.mk b/lib/libutils/isoc/arch/arm/softfloat/source/sub.mk
index c1d29cb..41bf696 100644
--- a/lib/libutils/isoc/arch/arm/softfloat/source/sub.mk
+++ b/lib/libutils/isoc/arch/arm/softfloat/source/sub.mk
@@ -63,3 +63,6 @@ srcs-y += s_countLeadingZeros64.c
 srcs-y += s_mul64To128.c
 
 srcs-y += softfloat_state.c
+
+cflags-y += -fno-sanitize=all 
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/lib/libutils/isoc/arch/arm/sub.mk b/lib/libutils/isoc/arch/arm/sub.mk
index bac691c..5e618c8 100644
--- a/lib/libutils/isoc/arch/arm/sub.mk
+++ b/lib/libutils/isoc/arch/arm/sub.mk
@@ -20,3 +20,6 @@ cflags-arm32_aeabi_softfloat.c-y += -Wno-missing-declarations
 subdirs-$(CFG_ARM32_$(sm)) += softfloat
 endif
 endif
+
+cflags-y += -fno-sanitize=all 
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/lib/libutils/isoc/newlib/sub.mk b/lib/libutils/isoc/newlib/sub.mk
index c46dab7..c7a7e00 100644
--- a/lib/libutils/isoc/newlib/sub.mk
+++ b/lib/libutils/isoc/newlib/sub.mk
@@ -16,4 +16,9 @@ srcs-y += abs.c
 srcs-y += strchr.c
 srcs-y += strstr.c
 srcs-y += strcpy.c
-srcs-y += strncpy.c
\ No newline at end of file
+srcs-y += strncpy.c
+
+cflags-y += -fno-sanitize=all 
+cflags-remove-y += -fsanitize-coverage=trace-pc
+
+#cflags-y += -fsanitize-coverage=trace-pc
diff --git a/lib/libutils/isoc/stack_check.c b/lib/libutils/isoc/stack_check.c
index ca8a9dc..aca7222 100644
--- a/lib/libutils/isoc/stack_check.c
+++ b/lib/libutils/isoc/stack_check.c
@@ -2,13 +2,25 @@
 /*
  * Copyright (c) 2014, STMicroelectronics International N.V.
  */
+
+#ifdef __KERNEL__
+#include <kernel/panic.h>
+#else
+#include <tee_api.h>
+#include <trace.h>
+
+#define panic(m) \
+	EMSG(m); \
+	TEE_Panic(TEE_ERROR_OVERFLOW);
+	
+#endif
+
 void *__stack_chk_guard = (void *)0x00000aff;
 
 void __attribute__((noreturn)) __stack_chk_fail(void);
 
 void __stack_chk_fail(void)
 {
-	while (1)
-		;
+	panic("Stack canary corrupted");
 }
 
diff --git a/lib/libutils/isoc/sub.mk b/lib/libutils/isoc/sub.mk
index 6348a92..d25b29a 100644
--- a/lib/libutils/isoc/sub.mk
+++ b/lib/libutils/isoc/sub.mk
@@ -20,3 +20,9 @@ srcs-y += tolower.c
 
 subdirs-y += newlib
 subdirs-$(arch_arm) += arch/$(ARCH)
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
+
+cflags-remove-bget.c-y += -fno-sanitize=all
+cflags-remove-bget_malloc.c-y += -fno-sanitize=all
\ No newline at end of file
diff --git a/lib/libutils/sub.mk b/lib/libutils/sub.mk
index e88e67d..75c92a3 100644
--- a/lib/libutils/sub.mk
+++ b/lib/libutils/sub.mk
@@ -3,4 +3,4 @@ subdirs-y += ext
 
 ifneq ($(sm),core) # User-mode
 cflags-lib-$(CFG_ULIBS_GPROF) += -pg
-endif
+endif
\ No newline at end of file
